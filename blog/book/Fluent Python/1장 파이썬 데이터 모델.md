<span>🔖 : 주제  📌 : 소주제  🗣 : 내 의견<span>

------------------------------------------------
<br>

# 1장 파이썬의 데이터 모델
🗣 사실 데이터 모델이라고 해서 Python의 데이터 모델이 아닌 Django에서 제공하는 Model이 떠오르는 것은 아직 Python을 깊이까지 알지 못하고 Python의 특성을 잘 파악하고 있지 못한것 같다. 

<br>

## 🔖 데이터 모델
Python에서의 데이터 모델은 일종의 프레임워크로서, 파이썬을 설명하는 것이라고 샐각할 수 있다. 시퀀스, 반복자, 함수, 클래스, 콘텍스트 관리자 등 언어 자체의 구성단위에 대한 인터페이스를 공식적으로 정의한 것을 말한다.

아래의 공식문서를 보면 객체, 값, 형, 계측, 특수 메서드, 코루틴 등을 데이터 모델이라고 지칭하는 것을 볼 수 있다.<br>
[파이썬-데이터 모델(공식문서)](https://docs.python.org/ko/3/reference/datamodel.html)

<br>

### 📌 특별 메서드 (던더 메서드)
<span style='color:orange;'>파이썬 인터프리터는 특별 메서드를 호출해서 기본적인 객체 연산을 수행하며, 종종 특별한 구문에 의해 호출이 된다.</span> 
- __ getitem__()처럼 이중 언더바를 가지고 있는 함수를 의미
- my_collection[key]가 호출되었다고 가정했을 때 Python의 인터프리터는 my_collection.__ getitem__(key)를 호출한다.

이런 특별 메서드는 우리가 구현한 객체가 아래와 같은 기본적인 언어 구조체를 지원하여 함께 사용할 수 있다.
- 반복
- 컬렉션
- 속성 접근
- 연산자 오버로딩
- 함수 및 메서드 호출
- 객체 생성 및 제거
- 문자열 표현 및 포맷
- 블록 등 콘텍스트 관리

🗣 이렇게 Python이 제공하는 던더 메서드를 Custom 클래스를 만들어, 내장 클래스들이 가지고 있는 기능을 구현 가능할 것이다. 

<br>

## 🔖 파이썬 카드 한 벌
던더 메서드가 어떻게 사용이 되는지 보여주는 첫 번째 예시이다.

<br>

### 📌 카드로 구성한 카드 한벌
```python
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:

    # 카드(숫자) 2~11 + J, Q, K, A
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')

    # 카드(모양) spades, diamonds, clubs, hearts
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]
    
    # __len__이 없으면 밖에서 호출하여도 호출되지 않음
    # 그렇다면 배열, 튜플, 셋 등 모든 클레스안에 __len__이 존재하다는 것을 의미
    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]
```
FrenchDeck이라는 Class를 작성하여 위에서 말한 것들을 예제로 보여준다.
- '카드 한 벌'을 담고있는 클래스이며 내장 인터페이스(__ init__, __ len__, __ getitem__)가 구현되어 있다.
- 카드 한벌이란 2~11까지의 숫자 및 JQKA와 스페이드, 다이아몬드, 클로버, 하트 모양을 가진 52가지 카드를 의미한다.
- Card에 대한 클래스를 따로 구현하지 않고 collections 모듈의 namedtuple로 클래스를 구현하였다.

<br>

***len() 인터프리터 실행***
```python
# __len__ 내장 인터프리터 구현
deck = FrenchDeck()
len(deck)

# 결과 : 52
```
이와 같이 파이썬 컬렉션과 마찬가지로 len()함수를 통해 본인이 가지고 있는 카드의 수를 반환한다.

<br>

***__ len__() 없이 인터프리터 실행***
```bash
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object of type 'FrenchDeck' has no len()
```
내부 메서드로 __ len__()함수를 작성하지 않고 len()을 사용하게 되면 위와 같은 에러를 발생하게 된다. 즉, <span style='color:orange;'>Custom으로 만드는 클래스에 len()함수를 사용하기 위해서는 내부 메서드로 __ len__()을 작성해야하며 내부 모듈인 컬렉션들은 모두 내부에 __ len__()함수가 작성되어 있다는 것을 유추</span>할 수 있다.

<br>

***obj[0] 인터프리터 실횅***
```python
# __getitem__ 내장 인터프리터 구현
deck[0]
deck[-1]

# 결과 
# Card(rank='2', suit='spades')
# Card(rank='A', suit='hearts')
```
deck(카드 한 벌)에서 특정 카드를 읽을 수 있게 하는 던더 메서드는 __ getteim__()로서 특정 요소의 값을 제공해준다.

<br>

***random.choice***<br>
임의의 카드를 골라내는 메서드를 정의해야 하는가? 그럴 필요 없이 파이썬은 시퀀스에서 항목을 무작위로 골라내는 random.choice()라는 메서드를 제공한다.

```python
from random import choice

choice(deck)
choice(deck)
choice(deck)

# 결과
# Card(rank='9', suit='spades')
# Card(rank='8', suit='hearts')
# Card(rank='K', suit='diamonds')
```

<br>
    
### 📌 특별 메서드의 두가지 장점
- 사용자가 표준 연산을 수행하기 위해 클래스 자체에서 구현한 임의 메서드명을 암기할 필요가 없다.
- 파이썬 표준 라이브러리에서 제공하는 풍부한 기능을 별도로 구현할 필요 없이 바로 사용할 수 있다.

__ getitem__()메서드는 self._card의 []연산자에 작업을 위임하므로 deck객체는 슬라이싱도 자동으로 지원한다.

<br>

***슬라이싱 자동 지원***
```python
# 슬라이싱 자동 지원
deck[:3]
deck[12::13]

# 결과
# [Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]
# [Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]
```
이와 같이 새로 생성한 deck객체에서 앞의 카드 세장을 가져온다거나, 12번 인덱스에서 13개씩 건너뛰어 에이스만 가져오게 슬라이싱이 가능하다.

그 외 반복은 암묵적으로 수행되는 경우가 있는데, 컬렉션에 __ contains__() 메서드가 없다면 in 연산자는 차례대로 검색한다.

## 🔖 결론
FrenchDeck이 암묵적으로 object를 상속받지만, 상속 대신 데이터 모델과 구성을 이용해서 기능을 가져온다. __ len__()과 __ getitem__() 특별 메서드를 구현함으로써 FrenchDeck은 표준 Python 시퀀스처럼 작동하므로 반복 및 슬라이싱 등의 핵심 언어 기능 및 random의 choice(), reversed(), sorted()함수를 사용한 예제에서 본 것처럼 표준 라이브러리를 사용할 수 있다.













